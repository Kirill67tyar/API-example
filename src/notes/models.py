from django.db.models import Model, CharField, TextField, DateTimeField, ForeignKey, SET_NULL
# from django.db import models
from django.conf import settings

User = settings.AUTH_USER_MODEL


class Note(Model):

    title = CharField(max_length=255)
    text = TextField(blank=True)
    created = DateTimeField(auto_now_add=True)
    updated = DateTimeField(auto_now=True)
    author = ForeignKey(User, null=True, blank=False, on_delete=SET_NULL, related_name='notes', verbose_name='Автор')
    # null=True и blank=True, здесь потому что нам в дальнейшем нужно буде привязать уже существующие записи
    # к какому-нибудь пользователю
    # (null-True - поле может быть пустым в бд)
    # (blank-True - форма можно оставлять незаполненой (правила валидации))
    # on_delete=CASCADE - означает, что при удалении записи удалятся тоже

    def __str__(self):
        return self.title

    class Meta:
        ordering = '-updated',



# пользователи при доступе к API стучатся в django по какому-то определенному url.
# доступ к API может запрашивать браузер, мобильное приложение, другой сайт (возможно через парсинг).
# Важно, в ответ вместо html страницы ожидается json или xml файл. Сооветсвенно с какими-то данными,
# из бд, обработанными в обработчике.
# Если такой файл не обнаруживается, ожидается не просто html страница 404,
# а status 404 (я так понимаю в http ответе, но это не точно)
# код ответа ожидается, статус HTTP
# разрешенные методы http запроса, и вообще сам по себе http запрос - краеугольный камень API
# Самая главная фишка обработчика для api - обработчик должен вернуть json или xml файл.
# И чтобы json или xml получить - создается прослойка как serializer
# (см. схемы цикла mvc паттерна, и api на телефоне фото)
# Сериалайзер позволяет преобразовывать данные из json в объекты python,
# чтобы их можно было записывать в бд (через orm)
# И в обратную сторону - те данные, что приходят из бд, сериалайзер приобразовывает из объектов python или django
# в данные с форматом json, отдает в котроллер, и данные идут дальше тому приложению, которое их запрашивало.
# Помни, котнтроллер работает опираясь не только на адрес, но и на метод по котрому пришли данные.
# И вроде как по такому принципу строится работа web api, написанная не только на django, но и на flask,
# и даже приложениях, написанных на других языках.

# При сочетании того, какой был адрес, и какой был метод отправлен в http запросе,
# и происходит определение действия что нужно сделать

# про метод post
# сервер ожидает в теле запроса post данные для добавления новой записи в бд

# Значит в теле запроса информация, которая отправляется клиентом. А в head запроса - ин-фа о самом этом запросе

# !!! В общем повтори урок 10, он очень полезен !!!

# API в web это легализованный способ доступа информации, который прописывает обладатель информации
# доступ в db
# это специальное приложение, которое позволяет распарсить инфу с сайта официально и через формат json
# а не с помощью библиотеки BeautifulSoup, где мы вычленяем информацию из тегов.
# и кстати даже добавлять, изменять, удалять эту инфу.

# Как получить json данные с официальной api? в requests для этого как раз и нужен метод json()
# делаем get запрос по нужному url, который выдает сухую json ин-фу.
# жалетельно в headers указать {'Accept': 'application/json'}
# и в полуенном response используй метод json()
# открой файл http_requests.py в django_repeat_07 и посмотри
# если нужно при получении get запроса указать get параметры - необязательно их указывать в url
# можно их передать в виде словаря в именованный аргумент params.

# при парсинге не забывай, что значением в словаре могут быть не только булевые, строка, и integer
# могут быть и вложенные объекты. Это другие json данные (словари) или списки. Так что обращаться
# к ним нужно или по ключу, или по индексу.

# Написано, что получать доступ к сайтам при скрапинге можно или через url или напрямую посылая http запросы.
# Скорее всего библиотека requests так и делает, напрямую посылает get запросы (но это не точно)

# как узнать можно ли скрапить на сайте, и какие для этого существуют правила?
# нужно добавить в url к основному домену /robots.txt
# Если такой страницы нет на сайте, то скорее всего ее можно парсить

# именованный аргумент data при requests.post() это по сути тело запроса
# то что будет передаваться в теле запроса.






# Общение клиента с api происходит через http методы, и http заголовки

# Важно помнить, что пользователь не только, при использовании api, получает данные в формате json,
# но и отправляет их с post запросом тоже в формате json. И изменяет кстати тоже.
# Работа с сериализаторами очень похожа на работу с формами

# requests library
# основной функционал библиотеки requests - отправлять запросы к серверу по определенному
# адресу (get, post, put, delete запросы) и получает в ответ - то что пришло с сервера.
# библиотека, которая моделирует работу внешних устройств, а именно, каких то мобильных приложений.
# Происходит обмен через http протокол. Все что можно предоставить для мобильного устройства
# можно моделировать через библиотеку requests
#
# Собственно при написании контроллеров rest_framework есть две тактики:
# 1я - писать самому контроллеры, можно через функции, можно через классы
# 2я - использовать class based view, в основном GenericAPIView из rest_framework.generics,
# т.е. отдать функционал на волю rest_framework (использовать готовые решения).
# Каждый подход имеет свои плюсы и минусы.

# При создании api имеет смысл подход, когда ты при показе списка объектов (записей в бд)
# показываешь не всю ин-фу о них, а поверхнустную ин-фу, актуальную для списка.
# Подробная ин-фа может быть нужна, когда ты показываешь какую-то запись в списке.
# Сделать, чтобы ин-фа в списке была не полной довольно просто - новый сериалайзер.
# Но часто бывает важно, чтобы в записи был указан url адрес записи.
# Я этот сделал самостойтельно, и с помощью урока (возможно более правильно).
# В общем смотри на функцию HyperlinkedIdentityField
# (обрати внимание что заканивается она на field, т.е. это поле)


#                               mixins
# Фактически миксины вводят в API парадигму CRUD. Когда мы общаемя не только методами http
# а функционалом CRUD, коммандами create, reade, update, delete
# Зайди в файл mixins.py, и помотри какие комманды там реализованы

# GenericAPIView - базовый класс, который определяет методы для дальнейшей работы всего API
# Во многом он взаимодействует (interacting) с  mixins, миксинами.


#                               viewsets
# Открой файл viewsets (rest_framework.viewsets)
# Есть обычный ViewSet, а есть ModelViewSet (который уже подвязывается к модели автоматически),
# по анологии с формами и сериалайзерами (ModelForm, ModelSerializer)

# Тут есть некоторое неудобство в том, то мы определяем два класса
# через GenericAPIView (для list и retrieve)
# ModelViewSet заимствуется от List, Create, Retrieve, Update, Destroy ModelMixin
# И от GenericViewSet, который имеет свою иерархию и наследуется от ViewSetMixin (базовый класс для viewset)
# и GenericAPIView. В общем загляни в файл viewsets.py

# Короче, если вкратце, то смысл viewset - просто полноятью объединять
# CreateModelMixin, ListModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin


# ---------------------------------- from accounts------------------------------------
# Откуда брать юзера по дефолту?
# Ответ, смотри в настройках константу AUTH_USER_MODEL
# Теперь django будет использовать модель User, которую мы переопределили

# Почему в Django нужно первым создавать модели юзера, и аккаунты?
# При первой миграции мы создаем бд на основе User, уже встроенной в Django,
# И если мы хотим переопределить User в дальнейшем,
# Нам придется грохнуть всю бд. Безболезненно это проходит редко, и записи в бд могут пострадать
# ---------------------------------- from accounts------------------------------------

# Мои мысли: Грубо говоря разработчик API - связующее звено между бд и фронтэндером.
# Он должен доставать данные из бд и предоставлять их фронтэндеру. API - это бд для фронтэндера


#                           permissions

# В drf есть три базовых permissions (доступа), (поправка, на самом деле этих доступов больше):
# IsAuthenticated
# IsAdminUser
# IsAuthenticatedOrReadOnly

# https://www.django-rest-framework.org/api-guide/permissions/#isauthenticated
# https://www.django-rest-framework.org/api-guide/permissions/#permissions

# Импортируются from rest_framework.permissions import ...

# Впринципе ничего сложного вроде.
# Пошаби в файле permissions.py - интересно
# permissions (классы доступа разрешения) просто дают доступ тем или иным пользователям
# Важный момент: в базовом классе User есть аттрибуты is_staff, is_admin
# все они доступны через HTTP запрос (request.user)
# Вот на эти аттрибуты объекта и опирается работа с permissions,
# классы permissions работают с этими аттрибутами.
# А эти аттрибуты становятся известны благодаря request (вспомни, request.user)
# В итоге я написал свой permission, чекай permissions.py в api.permissions
# Там все просто, вспоминай.

# Но момент, после всех этих пермишинсов, когда отправляешь put запрос, редактируя запись
# в списке записей это изменение отображается только если перезапустить сервер.
# Даже сбросить кэш не помогает. И причем это работает не только на базовой странице api
# Но и при использовании других сервисов, например postman
# Изменения отобажаются не сразу также и при методе HTTP post. Странная фигня.
# Закрыв postman отображаться стало сразу.

# В django rest_framework есть свои классы фильтрации. Как мы определяем queryset?
# Мы записываем queryset в классе View
# Дальше мы переопредяем queryset в get_queryset, используя в фильтрации look_up
# А можно по другому. Можно прописать filter_backends в аттрибутах класса.
# Этот класс будет отвечать за фильтрацию. Его можно переопределять.
# В общем смотри job.scraping.api views.py.
# По фильтрации в DRF можно почитать https://www.django-rest-framework.org/api-guide/filtering/
# Обрати внимание на кастомный класс фильтрации